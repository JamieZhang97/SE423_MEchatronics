{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Consolas;}}
{\colortbl\red0\green0\blue0;\red255\green0\blue0;\red0\green120\blue215;\red128\green0\blue128;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title 2.2.rtf}}

\deflang1033\pard\plain\f0\fs18 \cf0\b int\b0  Fix_Equivalency\cf1\b (\cf0 int\b0  num_equivalencies_used\cf1\b )\b0\cf0  \cf1\b \{\b0\cf0  \cf2\i // Fixes equivalency to ordered values, returns num. objects..
\par 
\par \i0\cf0 	\b int\b0  i\cf1\b ;
\par \b0\cf0     \b int\b0  ordered_num \cf1\b =\b0\cf0  \cf3 1\cf1\b ;
\par \b0\cf0     \b int\b0  num_unique \cf1\b =\b0\cf0  \cf3 0\cf1\b ;
\par \b0\cf0     \b int\b0  done \cf1\b =\b0\cf0  \cf3 0\cf1\b ;
\par \b0\cf0     \b int\b0  current \cf1\b =\b0\cf0  \cf3 0\cf1\b ;
\par \b0\cf0     
\par     \b int\b0  num_equivs \cf1\b =\b0\cf0  num_equivalencies_used\cf1\b +\b0\cf3 1\cf1\b ;
\par 
\par \b0\cf0     \cf2\i // just in case invalid parameter sent
\par \i0\cf0     \cf2\i // make sure the number of the flag being used is less than the memory space 
\par \i0\cf0     \b if\b0  \cf1\b (\b0\cf0 num_equivs \cf1\b >\b0\cf0  MAX_NUM_EQUIVALENCIES\cf1\b )\b0\cf0  num_equivs \cf1\b =\b0\cf0  MAX_NUM_EQUIVALENCIES\cf1\b ;
\par \b0\cf0     \b if\b0  \cf1\b (\b0\cf0 num_equivs \cf1\b <\b0\cf0  \cf3 1\cf1\b )\b0\cf0  num_equivs \cf1\b =\b0\cf0  \cf3 1\cf1\b ;
\par \b0\cf0     
\par     \cf2\i // zero temp link array
\par \i0\cf0     \cf2\i // initial with zero 
\par \i0\cf0     \b for\b0  \cf1\b (\b0\cf0 i\cf1\b =\b0\cf3 1\cf1\b ;\b0\cf0  i \cf1\b <\b0\cf0  num_equivs\cf1\b ;\b0\cf0  i\cf1\b ++)\b0\cf0  \cf1\b \{
\par \b0\cf0         temp_equivalency_objects\cf1\b [\b0\cf0 i\cf1\b ]\b0\cf0  \cf1\b =\b0\cf0  \cf3 0\cf1\b ;
\par \b0\cf0     \cf1\b \}
\par 
\par \b0\cf0     \b for\b0  \cf1\b (\b0\cf0 i\cf1\b =\b0\cf3 1\cf1\b ;\b0\cf0  i \cf1\b <\b0\cf0  num_equivs\cf1\b ;\b0\cf0  i\cf1\b ++)\b0\cf0  \cf1\b \{
\par \b0\cf0         
\par         \b if\b0  \cf1\b (\b0\cf0  \cf1\b (\b0\cf0 temp_equivalency_objects\cf1\b [\b0\cf0 i\cf1\b ]\b0\cf0  \cf1\b ==\b0\cf0  \cf3 0\cf1\b )\b0\cf0  \cf1\b &&\b0\cf0  \cf1\b (\b0\cf0 equivalency_objects\cf1\b [\b0\cf0 i\cf1\b ]\b0\cf0  \cf1\b !=\b0\cf0  \cf3 0\cf1\b )\b0\cf0  \cf1\b )\b0\cf0  \cf1\b \{
\par \b0\cf0             temp_equivalency_objects\cf1\b [\b0\cf0 i\cf1\b ]\b0\cf0  \cf1\b =\b0\cf0  ordered_num\cf1\b ;
\par \b0\cf0             ordered_num\cf1\b ++;
\par \b0\cf0             done \cf1\b =\b0\cf0  \cf3 0\cf1\b ;
\par \b0\cf0             current \cf1\b =\b0\cf0  equivalency_objects\cf1\b [\b0\cf0 i\cf1\b ];\b0\cf0  \cf2\i //first give current a connected object number
\par \i0\cf0             \b while\b0  \cf1\b (\b0\cf0 done \cf1\b ==\b0\cf0  \cf3 0\cf1\b )\b0\cf0  \cf1\b \{\b0\cf0     \cf2\i //if the are the same, change the flag to fixing has finished
\par \i0\cf0                 \b if\b0  \cf1\b (\b0\cf0 current \cf1\b ==\b0\cf0  i\cf1\b )\b0\cf0  done \cf1\b =\b0\cf0  \cf3 1\cf1\b ;
\par \b0\cf0                 \b else\b0  \cf1\b \{\b0\cf0              \cf2\i //if not the same, change to the same number
\par \i0\cf0                     \b if\b0  \cf1\b (\b0\cf0 temp_equivalency_objects\cf1\b [\b0\cf0 current\cf1\b ]\b0\cf0  \cf1\b ==\b0\cf0  \cf3 0\cf1\b )\b0\cf0  \cf1\b \{
\par \b0\cf0                         temp_equivalency_objects\cf1\b [\b0\cf0 current\cf1\b ]\b0\cf0  \cf1\b =\b0\cf0  temp_equivalency_objects\cf1\b [\b0\cf0 i\cf1\b ];
\par \b0\cf0                     \cf1\b \}\b0\cf0               \cf2\i //give the current pixel the changed number
\par \i0\cf0                     current \cf1\b =\b0\cf0  equivalency_objects\cf1\b [\b0\cf0 current\cf1\b ];
\par \b0\cf0                 \cf1\b \}\b0\cf0 	
\par             \cf1\b \}
\par \b0\cf0         \cf1\b \}
\par \b0\cf0         
\par 	\cf1\b \}
\par \b0\cf0     
\par     num_unique \cf1\b =\b0\cf0  ordered_num \cf1\b -\b0\cf0  \cf3 1\cf1\b ;
\par \b0\cf0 	
\par 	\cf2\i // Copy equivalencies over		
\par \i0\cf0 	\b for\b0  \cf1\b (\b0\cf0 i\cf1\b =\b0\cf3 1\cf1\b ;\b0\cf0  i \cf1\b <\b0\cf0  num_equivs\cf1\b ;\b0\cf0  i\cf1\b ++)\b0\cf0  \cf1\b \{
\par \b0\cf0 		equivalency_objects\cf1\b [\b0\cf0 i\cf1\b ]\b0\cf0  \cf1\b =\b0\cf0  temp_equivalency_objects\cf1\b [\b0\cf0 i\cf1\b ];
\par \b0\cf0 	\cf1\b \}
\par \b0\cf0     
\par     \cf2\i //limit the number of object 
\par \i0\cf0     \b if\b0  \cf1\b (\b0\cf0  num_unique \cf1\b >\b0\cf0  MAX_NUM_OBJECTS \cf1\b )\b0\cf0   \cf1\b \{
\par \b0\cf0         num_unique \cf1\b =\b0\cf0  MAX_NUM_OBJECTS\cf1\b ;
\par \b0\cf0     \cf1\b \}
\par \b0\cf0 	
\par 	\cf2\i // Add up totals, since many different objects now refer to same final object 
\par \i0\cf0 	\cf2\i //change all the objects connected into one object, add up the pixels position and number of pixels
\par \i0\cf0 	\b for\b0  \cf1\b (\b0\cf0 i\cf1\b =\b0\cf3 1\cf1\b ;\b0\cf0  i \cf1\b <\b0\cf0  num_equivs\cf1\b ;\b0\cf0  i\cf1\b ++)\b0\cf0  \cf1\b \{\b0\cf0 	
\par 		\b if\b0  \cf1\b (\b0\cf0 equivalency_objects\cf1\b [\b0\cf0 i\cf1\b ]\b0\cf0  \cf1\b <=\b0\cf0  num_unique\cf1\b )\b0\cf0  \cf1\b \{
\par \b0\cf0 			final_object_stats\cf1\b [\b0\cf0 equivalency_objects\cf1\b [\b0\cf0 i\cf1\b ]].\b0\cf0 num_pixels_in_object \cf1\b +=\b0\cf0  object_stats\cf1\b [\b0\cf0 i\cf1\b ].\b0\cf0 num_pixels_in_object\cf1\b ;
\par \b0\cf0 			final_object_stats\cf1\b [\b0\cf0 equivalency_objects\cf1\b [\b0\cf0 i\cf1\b ]].\b0\cf0 sum_r \cf1\b +=\b0\cf0  object_stats\cf1\b [\b0\cf0 i\cf1\b ].\b0\cf0 sum_r\cf1\b ;
\par \b0\cf0 			final_object_stats\cf1\b [\b0\cf0 equivalency_objects\cf1\b [\b0\cf0 i\cf1\b ]].\b0\cf0 sum_c \cf1\b +=\b0\cf0  object_stats\cf1\b [\b0\cf0 i\cf1\b ].\b0\cf0 sum_c\cf1\b ;
\par \b0\cf0 		\cf1\b \}
\par \b0\cf0 	\cf1\b \}
\par 
\par \b0\cf0 	\cf2\i // Calculate the average pixel values
\par \i0\cf0 	\cf2\i // calculating the center of each final object
\par \i0\cf0 	\b for\b0  \cf1\b (\b0\cf0 i\cf1\b =\b0\cf3 1\cf1\b ;\b0\cf0  i \cf1\b <=\b0\cf0  num_unique\cf1\b ;\b0\cf0  i\cf1\b ++)\b0\cf0  \cf1\b \{
\par \b0\cf0 		\b if\b0  \cf1\b (\b0\cf0 final_object_stats\cf1\b [\b0\cf0 i\cf1\b ].\b0\cf0 num_pixels_in_object \cf1\b !=\b0\cf3 0\cf1\b )\b0\cf0  \cf1\b \{
\par \b0\cf0 			final_object_stats\cf1\b [\b0\cf0 i\cf1\b ].\b0\cf0 center_r \cf1\b =\b0\cf0  final_object_stats\cf1\b [\b0\cf0 i\cf1\b ].\b0\cf0 sum_r\cf1\b /\b0\cf0 final_object_stats\cf1\b [\b0\cf0 i\cf1\b ].\b0\cf0 num_pixels_in_object\cf1\b ;
\par \b0\cf0 			final_object_stats\cf1\b [\b0\cf0 i\cf1\b ].\b0\cf0 center_c \cf1\b =\b0\cf0  final_object_stats\cf1\b [\b0\cf0 i\cf1\b ].\b0\cf0 sum_c\cf1\b /\b0\cf0 final_object_stats\cf1\b [\b0\cf0 i\cf1\b ].\b0\cf0 num_pixels_in_object\cf1\b ;
\par \b0\cf0 		\cf1\b \}
\par \b0\cf0 	\cf1\b \}
\par \b0\cf0 	
\par 	\cf2\i // Now have ordered_num-1 unique objects
\par \i0\cf0 	\b return\cf1 (\b0\cf0 num_unique\cf1\b );
\par \}
\par }